//Наследование
//Важно для всего ООП
//Надо знать
//Изучить на стороне

class Human {
    var firstName: String = "" //Propertie
    var lastName: String = ""
    
    var fullName:String {            //computed propertie - вычисляемое свойство
        return firstName + " " + lastName   //у нас только геттер - поэтому его не расписываем
    }
    
    func sayHello() -> String {     //метод
        return "hello"
    }
}
//В наследовании участвуют только классы
//Базовый класс - который ни от кого не наследуется
let people01 = Human() //создали объект/экземпляр класса Хьюман
people01.firstName = "Alex"
people01.lastName = "Skutarenko"
people01.sayHello()
people01.fullName

//создадим класс студент с методом sayHello
//с теми-же свойствами и методами что и у хьман - для этого придется просто копировать, дублировать код, но так делать нельзя
//делаем наследование - оно объединяет классы по общим "вещам"
class Student:Human { //создали наследующий класс от хьюман
    override func sayHello() -> String { //переопределили родительский метод sayhello
        return super.sayHello() + " My Friend" //возвращаем функцию родителя + от себя добавляем
    }
} //когда один класс наследуется от другого он принимает абсолютно все свойства хранимые и вычисляемые, а так-же методы

class SmartHuman:Human {
    var favoriteScience:String = "Geometry" //добавили личное свойство для подкласса
}

let student = SmartHuman() //не смотря на родителя смартХуман - обращаемся выше к классу Хуман, т.к. смарт хуман наследник хумана
student.firstName = "Max"
student.lastName = "Mix"
student.fullName
student.sayHello()
student.favoriteScience
//Экземпляр класса студент полностью унаследовал все свойства от хьюман

class Kid:Human{
    override func sayHello() -> String {
        return "agu"
    }
    override var fullName: String {
        return firstName
    }
    
    override var firstName: String {
        set {
            super.firstName = newValue + ":)"
        }
        get {
            return super.firstName
        }
    }
    
    override var lastName: String {
        didSet {
            print ("new value = " + self.lastName)
        }
    }
}
let kid = Kid()
kid.firstName = "Kid"
kid.lastName = "Kids"
kid.sayHello()
kid.fullName //вернул только имя потому что мы переопределили свойство фуллнейм в наследуемом классе Кид
//не смотря на существующие методы, если нужно что-то изменить, переопределим родительский метод sayHello через override
//не путать с перегрузкой метода
//что бы расширить родительский метод - вызываем метод родительского класса (сделано в классе студент)
//оператор super обращается к родительскому классу
//можем переопределить любой метод/либо расширить
//переопределение свойств - через оверрайд
//дочерний класс не знает сторед или копутед проперти у родителя (важно при оверрайд)
//переопределять можно геттеры и сеттеры у дочернего вне зависимости от того как у родителя (геттеры/сеттеры/обсерверы)
//обсервер (willSet didSet для сторед проперти)
//новые проперти только у классов и подклассов где заданы, родители их не получают
//если мы используем конструкцию final func - ни один наследник не сможет переопределить метод, работает и со свойствами и даже с классом


let array: [Human] = [kid, student, people01] // в массив кладутся объекты только одного типа, в данном случае типа Human

for value in array {
    print (value.sayHello())
} //пробежались по каждому объекту в массиве и вызвали метод сейХеллоу

//homework
//базовый класс артист у него имя и фамилия и есть метод "когда выступают"
//у каждого будет свое выступление (танцует, поет и т.д)
//Художнику нельзя менять имя фамиилию - меняет на свое, когда вызывают метод выступление пишет кто выступает имя фамилию + выступление
//положить артистов в массив и вывести метод выступление еще что-то

//создать базовый класс транспортное средство скорость вместимость и стоимость перевозки - все компутед, далее создать несколько дочерних классов и переопределить это компутед свойство (именно через наследование)
//ТС создать самолет корабль машина поезд, метод считает стоимость и время в зависимости от расстояния, посчитать стоимость для н-человек
//рассчитать сколько надо будет времени поездок и общая стоимость

//пять разных классов люди обезьяны собаки жирафы крокодилы - создать родительский для группировки, создать пару объектов каждого класса, посчитать пресмыкающихся массивом
//посчитать четвероногих? животных? живых существ, объединять по родительскому признаку
